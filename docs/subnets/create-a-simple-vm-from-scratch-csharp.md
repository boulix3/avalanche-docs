# How to Build a Simple VM From Scratch using `C#`

This is part of a series of tutorials for building a Virtual Machine (VM):

- [Introduction to VMs](./introduction-to-vm.md)
- [How to Build a Simple Golang VM](./create-a-vm-timestampvm.md)
- [How to Build a Complex Golang VM](./create-a-vm-blobvm.md)
- [How to Build a Simple Rust VM](./create-a-simple-rust-vm.md)
- [How to Build a Simple VM From Scratch](./create-a-simple-vm-from-scratch.md)
- How to Build a Simple VM From Scratch using C# (this article)

## Introduction

This is a step by step guide on how to start creating a Subnet using C#. The end result is a
 _working but incomplete_ Subnet VM running on a local network.

It's a C# implementation of the previous guide
[how to create a Subnet from scratch](./create-a-simple-vm-from-scratch.md).

The source code corresponding to this guide is available on
[github](https://github.com/boulix3/subnet-from-scratch-csharp), and at the end
of each section, you will find the link to a branch representing the current
implementation.

## Pre-Requisites

This is for C# developers with little or no blockchain knowledge. This guide is
assuming you are using Linux, but it can probably work just as well on a mac, or
on windows using WSL2.

- [dotnet](https://dotnet.microsoft.com/en-us/download/dotnet) :
  You must follow the instructions to install .net to use the `dotnet` command.

Install useful dotnet tools in your project
_dotnet-grpc is a tool to manage Proto files easily, and avalanche .net CLI is a
tool to help you manage AvalancheGo binaries, and build and run your VMs
locally_

```sh
dotnet new tool-manifest
dotnet tool install dotnet-grpc
dotnet tool install avalanche
```

- [AvalancheGo](https://github.com/ava-labs/avalanchego/releases) :
  Extract the latest release in your ~/bin folder

- [avalanche-network-runner](https://github.com/ava-labs/avalanche-network-runner/releases) :
  Extract the latest release in your ~/bin folder

## Project Initialization

```sh
dotnet new grpc -n MySubnet
```

This will create a new project named MySubnet using the [dotnet grpc template](https://learn.microsoft.com/en-us/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-7.0&tabs=visual-studio-code).

This project is a basic ASP.NET Core gRPC Server, with an example GreeterService
built from the `greet.proto` file. We will remove these as we clean-up.

### Add Avalanche Proto Files

We manage the Proto references files using `dotnet-grpc` instead of using `buf`,
because it is so well integrated into .net tooling.

Open the `src/MySubnet/MySubnet.csproj`, and add the following `ItemGroup` to
add the minimum required Proto references.

```xml
  <ItemGroup>
    <Protobuf Include="../protos/io/prometheus/client/metrics.proto" Link="Protos/metrics.proto" GrpcServices="None">
      <SourceUrl>
        https://raw.githubusercontent.com/prometheus/client_model/master/io/prometheus/client/metrics.proto</SourceUrl>
    </Protobuf>
    <Protobuf Include="../protos/vm.proto" Link="Protos/vm.proto" GrpcServices="Server">
      <SourceUrl>https://raw.githubusercontent.com/ava-labs/avalanchego/master/proto/vm/vm.proto</SourceUrl>
    </Protobuf>    
    <Protobuf Include="../protos/runtime.proto" Link="Protos/runtime.proto" GrpcServices="Client">
      <SourceUrl>
        https://raw.githubusercontent.com/ava-labs/avalanchego/master/proto/vm/runtime/runtime.proto
      </SourceUrl>
    </Protobuf>    
  </ItemGroup>
```

Download the references and build your project

```sh
dotnet dotnet-grpc refresh
dotnet build
```

These commands download the Proto files from the specified urls, and builds the
project to generate the appropriate C# classes. You can execute these commands
whenever there is a new version of the Proto files. 

### Cleanup

- Delete all unnecessary files that were generated by the `dotnet grpc template` :
  - settings files : `appsettings.*`
  - folders : `Service`, `Properties` and `Protos`
- In `Program.cs`, remove the GreeterService registration `app.MapGrpcService<GreeterService>();`.
- In `MySubnet.csproj`, remove the block containing the reference to the
  `greet.proto` file `<Protobuf Include="Protos\greet.proto" GrpcServices="Server"
  />`.

### Empty Proto Implementations

Create a folder named Avalanche which will contain the needed classes for
communication between our VM and AvalancheGo. In this folder, create these two
classes:

- `RuntimeClient.cs` is used to call AvalancheGo's runtime service. It uses the
  `RuntimeClient` class generated from the `runtime.proto` file.

```csharp
namespace MySubnet.Avalanche;
public class RuntimeClient
{
    private Vm.Runtime.Runtime.RuntimeClient _grpcClient;
    public RuntimeClient(Vm.Runtime.Runtime.RuntimeClient grpcClient)
    {
        _grpcClient = grpcClient;
    }
}
```

- `VmServer.cs` is the VM implementation called by AvalancheGo. It inherits the
  `VMBase` class generated from the `vm.proto` file. This is where we will need
  to implement the grpc service's methods.

```csharp
namespace MySubnet.Avalanche;
public class VmServer : Vm.VM.VMBase
{
}
```

We now have the basic structure of our project. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/project-initialization/src)

### Genesis file

We will need to provide a genesis file to initialize the VM, let's just create
an empty json file (`{}`) and name it genesis.json.

## Starting The Process

Avalanche will look in it's plugin folder (`~/.avalanchego/plugins/`) for a file
named with the VMId corresponding to the VM's name. You can get a VMId using
this [tool](https://avalanche-online-tools.web.app/).

For `MySubnet`, the corresponding VMId is `b7y7rNCYGFHBtRhrr5Y87KJML6MWVnx2MnLmnup6DpZafRpGr`.

To produce a single file binary, we need to modify `MySubnet.csproj` by adding
`<PublishSingleFile>true</PublishSingleFile><RuntimeIdentifier>linux-x64</RuntimeIdentifier>`
inside the main `<PropertyGroup>`.

Running `dotnet publish -o build` will produce a single binary :
`build/MySubnet`. That file needs to be in the plugins directory and named using
the VMId. `cp build/MySubnet
~/.avalanchego/plugins/b7y7rNCYGFHBtRhrr5Y87KJML6MWVnx2MnLmnup6DpZafRpGr` 

### Avalanche .Net CLI

Using the .Net tool is easier, it downloads AvalancheGo and
Avalanche-Network-Runner binaries and automates the process of building, and
starting a local network to try out your VM.

Initialize the tool using the `dotnet avalanche init` command. The prompt's
default values should be good. This will generate a file named
`avalanche.net.config`.

When the initialization is complete, we can run the project locally using the
`dotnet avalanche run` command.
The tool executes the following tasks using the information contained in the `avalanche.net.config`:

- If this is the first time it is run, it downloads AvalancheGo and
  Avalanche-network-runner in the `basePath` directory
- Build the project using the `vmBuildCommand`
- Copy the binary to `avalanchePluginsPath` and rename the file using the `VMId`
- Start a 5 node network using Avalanche-network-runner
- Register the Subnet and the VM

With our current implementation, this last step will fail of course, but we can
see in the console that our process has been started by AvalancheGo.

### Process Registration

While launching your binary, avalanche's go passes an environment variable
`AVALANCHE_VM_RUNTIME_ENGINE_ADDR` containing an url. We must use this url to initialize a
`vm.Runtime` client.
The `ProtocolVersion` constant matches the `supported plugin version` of the
[AvalancheGo release](https://github.com/ava-labs/AvalancheGo/releases).

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src/MySubnet/Program.cs#L5-L11
```

The `Kestrel` WebServer listens on port 5000 by default. We use port `0`
to force it to get a random unused port.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src/MySubnet/Program.cs#L15-L19
```

Register the `VmServer` service, start the WebServer and register the VM using
the `RuntimeClient.Initialize` method.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src/MySubnet/Program.cs#L32-L40
```

The RuntimeClient must call Avalanche's 
[`vm.Runtime.InitializeRequest`](https://buf.build/ava-labs/avalanche/docs/main:vm.runtime#vm.runtime.InitializeRequest)
Grpc method. It requires the current WebServer address in the following format :
`host:port`, and the protocol version defined earlier. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src/MySubnet/Avalanche/RuntimeClient.cs#L8-L49
```

At this point, we have not yet implemented any methods of the
[`vm.VM`](https://buf.build/ava-labs/avalanche/docs/main:vm) Proto. Let's start
by implementing the first method,
[VM.Version](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.VM.Version). 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src/MySubnet/Avalanche/VmServer.cs#LL15-L23
```

Execute `dotnet avalanche run` to try out the latest changes. By checking the
logs, the VM now registers correctly, and the `Version` method call is a
success. 

```log
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
[node2]       Executing endpoint 'gRPC - /vm.VM/Version'
[node2] info: MySubnet.Avalanche.VmServer[0]
[node2]       VmServer.Version called => 0.0.1.0
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
[node2]       Executed endpoint 'gRPC - /vm.VM/Version'
```

Since the `VmServer` class does not implement any other method, there are
errors, for example for the `Shutdown` call.

```log
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]
[node2]       Executing endpoint 'gRPC - /vm.VM/Shutdown'
[node2] info: Grpc.AspNetCore.Server.ServerCallHandler[7]
[node2]       Error status code 'Unimplemented' with detail '' raised.
[node2] info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]
[node2]       Executed endpoint 'gRPC - /vm.VM/Shutdown'
```

We now have a valid binary started by AvalancheGo. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/starting-process/src)

## VM Initialization

In this section, we must implement the methods described in the corresponding
section of the 
[language-agnostic
documentation](./create-a-simple-vm-from-scratch.md#vm-initialization)

For now, we will ignore all the `blockchain` logic and only focus on
making sure the VM is correctly initialized by AvalancheGo. 

[VmServer.cs](https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/VmServer.cs)
inherits from `VmBase`, an abstract class automatically generated from the
`vm.proto` file we referenced in our project file, `MySubnet.csproj`. If we look
at `VmBase`'s content, we will see that it implements all the methods from the
Proto file, but throws an exception in the body : 
`throw new RpcException(new Status(StatusCode.Unimplemented, ""));`

Avalanche Ids must be 32 bytes long and the protobuf C# implementation uses the
`Google.Protobuf.ByteString` type. We will create an `Id` class to with
operators to convert from and to `ByteString`.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/Id.cs#LL5-L16
```

For our VM initialization to be valid, we have to override those methods. For
now, we will return objects with these default values :

- Ids : `Id.Default` (32 bytes filled with zero)
- Err :
  [Error.Unspecified](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.Error) 
  to indicate that no error has occurred
- Other : filled with their default values


For example, here is the implementation of the Initialize method. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/VmServer.cs#LL38-L48C6
```

You can check-out the full [VmServer
implementation](https://github.com/boulix3/subnet-from-scratch-csharp/blob/vm-initialization/src/MySubnet/Avalanche/VmServer.cs).
This implementation is minimal, we only want our VM to register and initialize
correctly with AvalancheGo.

Execute `dotnet avalanche run` to try out the latest changes. After a few
minutes, we can see that the initialization process has ended without errors.

Our VM is now correctly initialized and started by AvalancheGo. You can find the source code
corresponding to this part in the [project-initialization
branch](https://github.com/boulix3/subnet-from-scratch-csharp/tree/vm-initialization/src)

## Building Blocks

We will now implement a very simple blockchain. For the sake of keeping this
guide as simple as possible, our blockchain will have the following
characteristics : 

- Transactions are not cryptographically signed
- Users are defined by their name, no public key
- Block contains balances
- Transfer transactions only
- Genesis contains two users: Alice and Bob

We will create the `AppSenderClient`, `MessengerClient`, and `HttpServer`
classes from the corresponding Proto interfaces.
We will also create the `Blockchain` class to manage our blocks.

We must also register them to be able to inject them using the dependency
injection provider.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Program.cs#L29-L31
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Program.cs#L36
```

### Blockchain Data

To keep things simple, we only need to keep track of blocks and transaction.
The [Blockchain
class](https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs)
will hold the data and will be registered as a singleton. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L18-L23
```

The `Block` class holds the following data:Balances, Transactions, Height, Hash,
and ParentHash. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/Block.cs#L6-L29
```

The `Transaction` class holds the following data:From, To, Amount, Status
and Hash.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/Transaction.cs#L7-L34
```

AvalancheGo's Proto interfaces, when managing data expects a byte array, which
corresponds to a
[ByteString](https://protobuf.dev/reference/csharp/api-docs/class/google/protobuf/byte-string)
on the classes generated from the Proto. We will use a non-performant but easy
to use converter that serializes the object to `json` and then transform it to a
`ByteString` using `UTF8` encoding.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Shared/HelperExtensions.cs#L41-L61
```

### JSON-RPC

To enable your json-RPC endpoint, you must implement the HandleSimple method of
the [`Http`](https://buf.build/ava-labs/avalanche/docs/main:http) interface. 


The `HandleSimple` method contains the original request. The request body is
most likely a `Json-RPC 2.0` object.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/HttpServer.cs#L25-L46
```

To keep things simple, we will support 3 methods : 

- `Transfer` to create a simple send transaction.
- `LatestBlock` to get the last accepted block.
- `BlockchainState` to get all our blockchain data (finalized blocks, pending
  blocks, and transaction pool).

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/HttpServer.cs#L48-L58
```

Let's see the implementation of the `Transfer` method. We must deserialize the
Json-RPC `params` field and 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/HttpServer.cs#L80-L93
```

### Transaction

The only supported transactions are simple transfers. For example, here is a
transaction where Bob sends 100 coins to Alice :

```json
{
  "from":"Bob",
  "to":"Alice",
  "amount":100
}
```

The transactions can have these statuses :

- Pending : In the transaction pool.
- Accepted : Valid transaction included in a block.
- Rejected : Invalid transaction included in a block.

Whenever a transaction is received, it is added to the transaction pool and
sent to the other nodes by calling the `AppSender.SendAppGossip` method.
The `_appsender` and `_blockchain` classes are injected in this class.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/HttpServer.cs#L80-L93
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/AppSenderClient.cs#L25-L27
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L42-45
```

When the `AppSender.SendAppGossip` method is called on one node, AvalancheGo
will gossip the message to all the other nodes. On these nodes, AvalancheGo will
call the
[VM.AppGossip](https://buf.build/ava-labs/avalanche/docs/main:vm#vm.VM.AppGossip)
method that we need to add to our VM implementation.

```csharp reference 
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L139-L144
```

### Blockchain Initialization

To get started, we need a genesis block that will be used during the
VM initialization part. When the `genesis` argument is passed to the program, we
will generate the `genesis.json` file using dummy data (Alice and Bob's
balances). 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Program.cs#L6-L10
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/Genesis.cs#L6-L24
```

Our VM implementation is empty for now (returning dummy data). We need to
implement the different method to parse and manage blocks.

Let's review some of these changes in detail. 

`Initialize` now parses the genesis block, adds it to our blockchain as a final
block, and the data returned comes from the parsed block. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L45-L59
```

`SetState` must return the latest final block.

```csharp reference 
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L98-L110
```

`ParseBlock` parses the block and adds it to our blockchain as a pending
block. The data returned comes from the parsed block.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L122-L137
```

At this point, we can start our VM using `dotnet avalanche run`, and we will
have a valid blockchain with a basic Json-RPC endpoint. 

You can import this [Postman
collection](https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet.postman_collection.json)
to send a transaction and check the blockchain state. When we send a
transaction and check the blockchain state, we see the transaction in the
transaction pool, but no blocks are built because the block building mechanism
is not yet implemented.

### Block Building

The `BackgroundWorker` class must be registered as a hosted service.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Program.cs#L27
```

When it is started, it checks every second if a new block can be built, and if
it can, it calls the `Messenger.NotifyBuildBlock` method. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BackgroundWorker.cs#L19-L36
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L96-L101
```

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/MessengerClient.cs#L25-L27
```

Supposing we have a 3 nodes network with _nodeX_, _nodeY_, _nodeZ_.
Our VM on _NodeX_ has decided that it's ready to issue a new block.

_on nodeX_

Our VM calls the `Messenger.Notify` method to notify AvalancheGo that a new
block can be built. When AvalancheGo is notified, it calls the `VM.BuildBlock`
method. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L146-L159
```

Our blockchain's block building mechanism is very simple. It takes all the
transactions in the transaction pool and adds them to the block. If the
transaction is valid, it as marked as accepted and the block's balances are
updated accordingly. Else, it is marked as rejected and balances are not
updated. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L47-L73
```

When a new block is built, AvalancheGo will perform the following calls to the
VM before broadcasting it to the other nodes:

`VM.BlockVerify` must check that the block is valid. If it is, we return the
block's timestamp property.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L161-L170
```

To verify the block's validity, we simply try to build a new one using the
block's transaction and timestamp. If the hashes are equal, then the block is
valid.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L111-L134
```

`VM.SetPreference` marks this block as the next preferred block for the current
node.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L172-L176
```

Now AvalancheGo will broadcast our block to the other nodes.

_on nodeY and nodeZ_

AvalancheGo will perform the following calls to the VM : 

`VM.ParseBlock` must parse the block, and add it to our `PendingBlocks` store,
just like we have done during the blockchain
[initialization](#blockchain-initialization) with the genesis block.

It will then call `VM.BlockVerify` and `VM.SetPreference`, just like on _nodeX_.

_on all nodes_

`VM.BlockAccept` must mark the block as final. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L178-L182
```

When the block is finalized, we must simply add it to our `FinalBlocks` store,
and clear any data related to any pending blocks since they are linked to the
previous block. 

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L25-L35
```

We also remove mark our newly accepted block as the `LatestBlock`. All its
transactions are also removed from the transaction pool.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L136-L141
```

### Managing Conflicts

Conflicts happen when two or more nodes propose the next block at the same time.
AvalancheGo takes care of this and decides which block should be considered
final, and which blocks should be rejected using Snowman consensus.
On the VM side, all there is to do is implement the `VM.BlockAccept` and
`VM.BlockReject` methods.

_nodeX proposes block `0x123...`, nodeY proposes block `0x321...` and nodeZ
proposes block `0x456`_

There are three conflicting blocks and AvalancheGo decides which block must
be accepted. Supposing it accepts block `0x123...`. The following RPC methods
are called on all nodes :

`VM.BlockAccept` with `0x123...` as the `Id` parameter.

`VM.BlockReject` with `0x321...` as the `Id` parameter.
`VM.BlockReject` with `0x456...` as the `Id` parameter.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/Avalanche/VmServer.cs#L184-L188
```

To reject the block, we simply remove it from the `PendingBlocks` store and
clear its `PreferedBlock` status.

```csharp reference
https://github.com/boulix3/subnet-from-scratch-csharp/blob/building-blocks/src/MySubnet/BlockChain/BlockChain.cs#L83-L88
```

## Trying Out

Let's try out our newly built VM. Run `dotnet avalanche run` to start our local
network. We will now execute some `curl` commands to interact with the Json-RPC
endpoint. Our 5 nodes listen on ports `9650`, `9652`, `9654`, `9656`, and
`9658`. In our examples, we will use various ports randomly to see that the
nodes are well synchronized.

These commands are included in this [Postman
collection](https://github.com/boulix3/subnet-from-scratch-csharp/blob/main/src/MySubnet.postman_collection.json)

When the nodes are fully ready, we can start by getting the latest block from
our Subnet VM by executing the `LatestBlock` endpoint: 

```shell
curl --location 'http://127.0.0.1:9652/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :1,
    "method" :"LatestBlock"    
}'
```

If the result is a 404, simply wait a little for the local network to finish
its startup.

The expected result is the genesis block : 

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": null,
  "result": {
    "balances": {
      "Alice": 1000,
      "Bob": 1000
    },
    "transactions": [],
    "height": 0,
    "timestamp": 1680605006469,
    "hash": "0xbc082052bf3c7ace9800d61a88be630a2527bd41baa116153d50a5ad75261324",
    "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
  }
}
```

Now, let's send some coins from Alice to Bob by executing the `Transfer`
endpoint : 

```shell
curl --location 'http://127.0.0.1:9650/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :3,
    "method" :"Transfer",
    "params":{
        "from":"Bob",
        "to":"Alice",
        "amount":100
    }
}'
```

The VM should register the transaction and the expected output should be : 

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "error": null,
  "result": {
    "from": "Bob",
    "to": "Alice",
    "amount": 100,
    "status": "Pending",
    "hash": "0xd1fff89a3d78ccc64541f110f466eef7efa3377bc3cbbd1cae759d55cc3710f1"
  }
}
```

Let's get the latest block again : 

```shell
curl --location 'http://127.0.0.1:9654/ext/bc/MySubnet' \
--header 'Content-Type: text/plain' \
--data '{
    "jsonrpc":"2.0",
    "id"     :1,
    "method" :"LatestBlock"    
}'
```

We can see the new block containing the previous transaction : 

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": null,
  "result": {
    "balances": {
      "Alice": 1100,
      "Bob": 900
    },
    "transactions": [
      {
        "from": "Bob",
        "to": "Alice",
        "amount": 100,
        "status": "Accepted",
        "hash": "0xd1fff89a3d78ccc64541f110f466eef7efa3377bc3cbbd1cae759d55cc3710f1"
      }
    ],
    "height": 1,
    "timestamp": 1680775417773,
    "hash": "0xcdc21e198df364971fea285dc4690f248fa97c46a83feb11e74702985f30e5d9",
    "parentHash": "0xbc082052bf3c7ace9800d61a88be630a2527bd41baa116153d50a5ad75261324"
  }
}
```
